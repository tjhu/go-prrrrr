@article{aot,
author = {M\o{}ller, Anders and Veileborg, Oskar Haarklou},
title = {Eliminating Abstraction Overhead of Java Stream Pipelines Using Ahead-of-Time Program Optimization},
year = {2020},
issue_date = {November 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {OOPSLA},
url = {https://doi.org/10.1145/3428236},
doi = {10.1145/3428236},
abstract = {Java 8 introduced streams that allow developers to work with collections of data using functional-style operations. Streams are often used in pipelines of operations for processing the data elements, which leads to concise and elegant program code. However, the declarative data processing style comes at a cost. Compared to processing the data with traditional imperative language mechanisms, constructing stream pipelines requires extra heap objects and virtual method calls, which often results in significant run-time overheads. In this work we investigate how to mitigate these overheads to enable processing data in the declarative style without sacrificing performance. We argue that ahead-of-time bytecode-to-bytecode transformation is a suitable approach to optimization of stream pipelines, and we present a static analysis that is designed to guide such transformations. Experimental results show a significant performance gain, and that the technique works for realistic stream pipelines. For 10 of 11 micro-benchmarks, the optimizer is able to produce bytecode that is as effective as hand-written imperative-style code. Additionally, 77% of 6879 stream pipelines found in real-world Java programs are optimized successfully.},
journal = {Proc. ACM Program. Lang.},
month = {nov},
articleno = {168},
numpages = {29},
keywords = {Java 8, program optimization, static program analysis}
}

@inproceedings{scala-jit,
author = {Prokopec, Aleksandar and Leopoldseder, David and Duboscq, Gilles and W\"{u}rthinger, Thomas},
title = {Making Collection Operations Optimal with Aggressive JIT Compilation},
year = {2017},
isbn = {9781450355292},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3136000.3136002},
doi = {10.1145/3136000.3136002},
abstract = { Functional collection combinators are a neat and widely accepted data processing abstraction. However, their generic nature results in high abstraction overheads -- Scala collections are known to be notoriously slow for typical tasks. We show that proper optimizations in a JIT compiler can widely eliminate overheads imposed by these abstractions. Using the open-source Graal JIT compiler, we achieve speedups of up to 20x on collection workloads compared to the standard HotSpot C2 compiler. Consequently, a sufficiently aggressive JIT compiler allows the language compiler, such as Scalac, to focus on other concerns.  In this paper, we show how optimizations, such as inlining, polymorphic inlining, and partial escape analysis, are combined in Graal to produce collections code that is optimal with respect to manually written code, or close to optimal. We argue why some of these optimizations are more effectively done by a JIT compiler. We then identify specific use-cases that most current JIT compilers do not optimize well, warranting special treatment from the language compiler. },
booktitle = {Proceedings of the 8th ACM SIGPLAN International Symposium on Scala},
pages = {29â€“40},
numpages = {12},
keywords = {partial escape analysis, functional combinators, collections, inlining, JIT compilation, data-parallelism, program optimization, iterators, scalar replacement},
location = {Vancouver, BC, Canada},
series = {SCALA 2017}
}